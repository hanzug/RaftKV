> 



# Q&A

## 你在这个项目中遇到了什么挑战，又是如何解决的呢？

> 1. 如何保证在分片迁移和删除操作时，不阻塞其他分片的读写操作
>
> 2. 其中主要的难点就是对Raft算法的理解，以及实现中的一些细节，对我来说最难的就是并发的一些东西。就是**设计好哪些地方该加锁，哪些地方不该加锁，即如何在保证并发数据正确的情况下，保证并发的性能**。

## 为什么能保证一个任期内至多只有一个领导者？

可以，通过选举的机制可以保证.

首先，candidate 竞选前会自增 term，因此 term 在总体上为单调递增趋势；

其次，在选举机制上，一个 term 内，一个 follower 只有一票，因此只能投票给一个 candidate；

最后，基于多数派原则，一个 candidate 只有拿到半数以上的赞同票才能当选 leader.

因此，同一个 term 内，不可能出现有两个 candidate 同时获得半数以上的赞同票，因此一个 term 至多只有一个 leader.

 

## 为什么能保证通过任期和索引相同的日志内容一定相同？

首先，预写日志具有 append-only 的性质，只作追加，不存在更新和删除操作；

其次，基于 7.1 可得知，同一个 term 只有一个 leader；

因此，在 term 相同的情况下，所有节点在同一个 index 上的日志都会与 term 内 leader 对应 index 位置的日志保持一致；

综上，term 和 index 共同组成了一个全局唯一标识键. 只要term 和 index 均相同，日志内容一定相同

 

## 如果两个节点中分别存在一笔任期和索引均相同的日志，那么在这两笔日志之前的日志是否也保证在顺序和内容上都完全一致？

可以.

（1）如 4.2 小节中 case2 和 case3 所述，对于节点 a，一笔 term = x、index = y 的预写日志允许被写入的前提是，其上一笔预写日志的任期和索引一定和 term 为 x 的leader 的上一笔日志相同；

（2）又由 7.2 小节证明，只要日志的索引和任期相同，其内容一定相同；

（3）进一步采用数学归纳法，可以推导得到，节点 a 从这笔写入日志开始向前追溯的所有日志均与任期为 x 的 leader 完全一致；

（4）倘若节点 b 也存在一笔 term = x、index = y 的日志，那么这笔日志一定也是由 term 为 x 的同一 leader 同步写入；

（5）与（2）（3）同理，节点 b 自此向前的所有日志都会与 leader 完全相同；

（6）于是可得，节点 a、b 自此向前的日志都完全相同.

 

## 关于选举机制方面，如何解决选票瓜分引发的问题？

试想一个场景，集群中有 a、b、c 3 个节点，三者网络环境以及硬件配置都非常相近.

其中，c 为leader，集齐两个节点形成共识即可视为多数派，接下来发生了如下事件：

（1）leader c 某时刻宕机；

（2）节点 a、b 心跳检测计时器同时超时，因此同时发起竞选；

（3）发起竞选时，a、b 都对任期加1，并且都会先把手中的一票投给自己，然后向对方拉票；

（4）由于 a、b 手中的票都已投给自己，因此会分别拒绝对方的拉票请求；

（5）a、b 都无法获得多数派的选票，竞选在同一时刻超时，并且同时发起下一轮竞选；

（6）接下来不断重复（3）-（5）步，a、b 陷入僵持局面，始终无人胜出，导致集群不可用.

 

解决方案：

每个节点在心跳超时阈值和竞选超时阈值上添加一个随机扰动值，通过这一扰动，避免多个节点在进入完全相同的竞选节奏. 于是进入 candidate 状态的节点有了先后之分，胜负自然就可见分晓.

 

## 为什么新任 leader 一定拥有旧 leader 已提交的日志？

这是由两阶段提交和选举流程中的多数派原则保证的：

（1）只有被集群多数派完成同步的日志才会被 leader 提交；

（2）在选举流程中，**节点只会把票投给日志进度不滞后于自身的 candidate；**

（3）在竞选流程，candidate 需要获取多数派的赞同票才能胜任，成为新任 leader.

基于第（3）点可知，新任 leader 的日志进度一定能在竞选流程的多数派中出于不滞后的地位.

而在集群节点个数固定的情况下，本轮竞选流程的多数派和认可前任 leader 同步日志请求的多数派至少存在一个重复的节点，否则就违背了多数派的语义（集群半数以上），因此可以得知，新任 leader 一定拥有前任 leader 那笔被多数派认可的日志，即旧 leader 提交的日志.

 

## 是否一项提议只需要被多数派通过就可以提交？

基于 7.5 小节可知，当一笔日志被多数派完成同步后，则后续所有新任的 leader 一定会拥有这笔日志，因此这笔日志已经被集群采纳，可以保证其安全性.

上面的论述看起来天衣无缝，然而，本小节所谈及问题的答案其实是否定的.

下面谈及一个极端的 case，并通过一个机制的补充，来让本节所关心的问题被彻底解决.

 

![图片](https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsXViaLNZcAicAH1KCEnfG9rtZib5dGnGicUG6KuR5eibgsiba2gsG1NqJTcb1Mcyo99NX9aibI32AsuTemg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

【极端 case】

背景：集群中存在 s1-s5 5 个节点，只需要 3 个节点达成共识，即可形成多数派.

（1）moment1：此时 leader 为 s1，term 为 1，s1 接受了一笔写请求，刚将其同步到 s1、s2，还未形成多数派时，s1 就宕机了；

（2）moment2：s5 收获了 s3、s4、s5 的选票，当选 leader，接受了一笔写请求，只在本机完成预写日志的落盘就宕机了；

（3）moment3：s1 收获了 s1、s2、s3、s4 的选票，重新当选 leader，继续推进 term = 1 时那笔遗留写请求的提交，成功将其同步到了 s1、s2、s3，获得多数派的认同，于是提交这笔写请求. 提交之后，s1 又宕机了.

（4）moment4：s2 由于遗留了一笔 term 为 2 的日志 term，领先集群所有节点，因此可以收获集群所有节点的选票. 于是 s5 再度当选 leader，继续推进 term 为 2 时遗留的写请求，由于这笔日志的 index 与第（3）步中 s1 同步日志的 index 相同，又因为其 term 值更大，最终会覆盖 s1、s2、s3 中的老日志，这就导致一笔已经被 s1 提交的日志最终被 s5 回滚了.

 

注意，在 raft 算法的设定中，已提交的日志就认为是写入成功了，是绝对不允许被回滚的，这种极端 case 就会 raft 算法的公信力造成破坏.

于是为解决这一问题，raft 算法中新增了一项限制，新上任的 leader 需要至少完成一笔本任期内的写请求，才能够执行提交动作.

补充这一设定后，在上述 case 的第（3）步，leader s1 尽管完成了 term 1 遗留日志的同步，也不能执行提交动作. 直到其完成一笔 term 3 的写请求之后，才能执行老日志的提交. 这是因为此时，集群中的多数派已经被**同步了 term 3 的日志，即使 s1 再发生宕机情况，s5 也不可能凭借 term2 的遗留日志而重新当选了.**

事实上，在工程实践上，通常每个 leader 上任之后，都会向集群广播同步一笔内容为空的日志，称之为 no-op. 只要这个请求被提交了，多数派也就写入了一遍当前任期的日志，于是本小节所谈及的异常问题就不可能再发生了.

 

## leader 向 follower 同步日志时，如何保证不出现乱序、丢失、重复的问题？

不乱序、不重复：follower 同步日志前，会校验上一笔日志是否和 leader 的上一笔完全一致，只有这样才会执行同步动作.

不丢失：基于 ack 机制保证. 倘若 leader 超时未收到 follower 同步日志的 ack，会重发同步日志请求.

 

## 如何保证各节点已提交的预写日志顺序和内容都完全一致？

假设节点 a 最后一笔已提交的预写日志的 term = x、index = y，这说明集群中有多数派认同了 term 为 x 的 leader 同步该笔日志的请求.

首先证明：倘若其他节点在 index = y 位置的日志已提交了，则这笔日志的 term 一定也为 x.

证明思路：倘若节点 b 在 index = y 处的日志已提交，且任期为 z，那么就说明集群中有多数派认可了任期为 z 的 leader 同步的 term = z、index = y 的日志的请求. 由于集群不可能存在两个对立的多数派，因此唯一的可能性就是 z = x，原题得证.

接下来基于 7.2 小节的证明结论，我们可以得知各节点在 term = x、index = y 前面部分的日志也都完全一致，即各节点已提交的预写日志顺序和内容都完全一致.

 

## 如何保证状态机数据的最终一致性？

基于 7.8 得知，被提交的预写日志顺序和内容都必然是完全一致的.

又由于只有被提交的预写日志才能被应用到状态机，因此状态机的数据必然会按照正确的顺序和请求内容被依次更新，最终一致性得以保证.

 

## 如何解决网络分区引发的无意义选举问题？

倘若集群产生网络分区，部分处于小分区的节点由于无法接收到 leader 的心跳，导致进入选举流程. 又因为网络分区问题，导致选举始终无法获得多数派的响应，最终 candidate 会无限自增 term. 直到网络恢复的那一刻，由于 candidate 异常的高 term，导致 leader 退位，集群进入新一轮的选举流程.

尽管小分区中的节点由于数据的滞后不可能在选举中胜出，最后必然是大分区中的节点胜任，节点数据的一致性依然可以得到保证. 但是这个无意义的选举过程同样会导致集群陷入暂不可用的阶段. 因此，我们可以通过这样的措施来避免这类无意义的选举：

每个 candidate 发起真实选举之前，会有一个提前试探的过程，试探机制是向集群所有节点发送请求，只有得到多数派的响应，证明自己不存在网络环境问题时，才会将竞选任期自增，并且发起真实的选举流程.

 

## 如果保证客户端提交写请求不丢失、不重复？

不丢失：通过 ack 机制保证. 客户端超时未收到服务端的 ack，则会重发请求.

不重复：客户端记录写请求的序列号，与服务端交互时透传这个序列号. 最终由服务端的 leader 实现对相同序列号写请求的幂等去重.